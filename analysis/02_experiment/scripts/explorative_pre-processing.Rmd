---
title: "Explorative Pre-processing for Replication of Larralde et Noveck (in prep) with disjunction"
author: Morgan Moyer
date: 6 March, 2023
output: html_document
---

```{r setup, include=FALSE, warning=FALSE, echo=FALSE}
library(ggplot2)
library(lme4)
library(lmerTest)
library(multcomp) # not available for this version of R
library(stringr)
library(textstem)
library(tidyverse)
theme_set(theme_bw())
cbPalette <- c("#56B4E9", "#D55E00", "#009E73","#999999", "#E69F00")
```


```{r set wd and read-in data, include=FALSE, warning=FALSE, echo=FALSE}
# Set wd
this.dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(this.dir)
source("../../helpers.R")

# User-defined function to read in PCIbex Farm results files
read.pcibex <- function(filepath, auto.colnames=TRUE, fun.col=function(col,cols){cols[cols==col]<-paste(col,"Ibex",sep=".");return(cols)}) {
  n.cols <- max(count.fields(filepath,sep=",",quote=NULL),na.rm=TRUE)
  if (auto.colnames){
    cols <- c()
    con <- file(filepath, "r")
    while ( TRUE ) {
      line <- readLines(con, n = 1, warn=FALSE)
      if ( length(line) == 0) {
        break
      }
      m <- regmatches(line,regexec("^# (\\d+)\\. (.+)\\.$",line))[[1]]
      if (length(m) == 3) {
        index <- as.numeric(m[2])
        value <- m[3]
        if (is.function(fun.col)){
         cols <- fun.col(value,cols)
        }
        cols[index] <- value
        if (index == n.cols){
          break
        }
      }
    }
    close(con)
    return(read.csv(filepath, comment.char="#", header=FALSE, col.names=cols))
  }
  else{
    return(read.csv(filepath, comment.char="#", header=FALSE, col.names=seq(1:n.cols)))
  }
}

d <- read.pcibex("../data/results.csv")
```



# Remove participants who are not accurate 


## remove anyone below 75% accuracy on test items (not overall)

```{r}
d.test <- d %>% 
  filter(Connective %in% c("and","but","so"))

inacc.below70 <- d.test %>% 
  # filter(Label == "test") %>% 
  group_by(ID) %>% 
  summarize(IndividualMeanAccuracy = mean(Answeraccuracy)) %>% 
  filter(IndividualMeanAccuracy < .75) 

d.test.accurate <- d.test %>% 
  filter(!ID %in% inacc.below70$ID)

# How much data removed?
1 - nrow(d.test.accurate)/nrow(d.test)

1 - nrow(d.test.accurate)/nrow(d)

```


# remove unsucessful trials 

```{r}
d.test.accurate.sucessful <- d.test.accurate %>% 
  group_by(ID,TrialID) %>% 
  filter(Answeraccuracy != "0")

# How much removed?
1 - nrow(d.test.accurate.sucessful)/nrow(d.test.accurate)
```


# Outlier removal for ReactionTime1 using IQR

## Raw RT1
```{r, trialRT outliers}
d.test.accurate.sucessful$ReactionTime1 <- as.numeric(d.test.accurate.sucessful$ReactionTime1)

summary(d.test.accurate.sucessful$ReactionTime1)
sd(d.test.accurate.sucessful$ReactionTime1)

hist(d.test.accurate.sucessful$ReactionTime1, breaks=20, col="red", xlab="RT (ms)",
        main="Histogram with Normal Curve")


mean(d.test.accurate.sucessful$ReactionTime1)
sd(d.test.accurate.sucessful$ReactionTime1)
range(d.test.accurate.sucessful$ReactionTime1)

# Remove the high range
cutoff <- quantile(d.test.accurate.sucessful$ReactionTime1,na.rm=TRUE)[4] + IQR(d.test.accurate.sucessful$ReactionTime1,na.rm=TRUE)*3 # 17309.75 
d.test.accurate.sucessful.IQR <- subset(d.test.accurate.sucessful, d.test.accurate.sucessful$ReactionTime1 < cutoff)
  
  
hist(d.test.accurate.sucessful.IQR$ReactionTime1, breaks=20, col="red", xlab="RT (ms)",
        main="Histogram with Normal Curve")
range(d.test.accurate.sucessful.IQR$ReactionTime1)
 
# remove the low range

cutoff.low <- quantile(d.test.accurate.sucessful$ReactionTime1,na.rm=TRUE)[4] - IQR(d.test.accurate.sucessful$ReactionTime1,na.rm=TRUE)*3 # 17309.75 

d.test.accurate.sucessful.IQR.both <- subset(d.test.accurate.sucessful.IQR, d.test.accurate.sucessful.IQR$ReactionTime1 > abs(cutoff.low))


hist(d.test.accurate.sucessful.IQR.both$ReactionTime1, breaks=20, col="red", xlab="RT (ms)",
        main="Histogram with Normal Curve")
range(d.test.accurate.sucessful.IQR.both$ReactionTime1)



# Finally how much from total raw test data?
1 - nrow(d.test.accurate.sucessful.IQR.both)/nrow(d.test) # almost 9%
1 - nrow(d.test.accurate.sucessful.IQR.both)/nrow(d.test.accurate.sucessful)

```

```{r}
write.csv(d.test.accurate.sucessful.IQR.both,"../data/explorative_raw_rt1_processed.csv")
```



## Same thing but using logRT nad IQR
```{r, logRT1 outliers}
d.test.accurate.sucessful$LogReactionTime1 <- as.numeric(log(d.test.accurate.sucessful$ReactionTime1))

mean(d.test.accurate.sucessful$LogReactionTime1)
sd(d.test.accurate.sucessful$LogReactionTime1)
summary(d.test.accurate.sucessful$LogReactionTime1)

hist(d.test.accurate.sucessful$LogReactionTime1,breaks=20, col="red", xlab="RT (ms)",
        main="Histogram with Normal Curve")

# Remove the high range
cutoff <- quantile(d.test.accurate.sucessful$LogReactionTime1,na.rm=TRUE)[4] + IQR(d.test.accurate.sucessful$LogReactionTime1,na.rm=TRUE)*3 # 17309.75 
d.test.accurate.sucessful.IQR <- subset(d.test.accurate.sucessful, d.test.accurate.sucessful$LogReactionTime1 < cutoff)
  
  
hist(d.test.accurate.sucessful.IQR$LogReactionTime1, breaks=20, col="red", xlab="RT (ms)",
        main="Histogram with Normal Curve")
range(d.test.accurate.sucessful.IQR$LogReactionTime1)
 
# remove the low range

cutoff.low <- quantile(d.test.accurate.sucessful$LogReactionTime1,na.rm=TRUE)[4] - IQR(d.test.accurate.sucessful$LogReactionTime1,na.rm=TRUE)*3 # 17309.75 

d.test.accurate.sucessful.IQR.both <- subset(d.test.accurate.sucessful.IQR, d.test.accurate.sucessful.IQR$LogReactionTime1 > abs(cutoff.low))


hist(d.test.accurate.sucessful.IQR.both$LogReactionTime1, breaks=20, col="red", xlab="RT (ms)",
        main="Histogram with Normal Curve")
range(d.test.accurate.sucessful.IQR.both$LogReactionTime1)

# Finally how much from total raw test data?
1 - nrow(d.test.accurate.sucessful.IQR.both)/nrow(d.test) # almost 9%
```

```{r}
write.csv(d.test.accurate.sucessful.IQR.both,"../data/explorative_log_rt1_processed.csv")
```

